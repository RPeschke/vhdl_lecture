-- XGEN: Autogenerated File

library IEEE;
library UNISIM;
library work;
use IEEE.numeric_std.all;
use IEEE.std_logic_1164.all;
use UNISIM.VComponents.all;
use ieee.std_logic_unsigned.all;
use work.argg_hdl_core.all;
use work.axisStream_slv32.all;


entity ram_block_tb is 
end entity;



architecture rtl of ram_block_tb is

--------------------------ram_block_tb-----------------
  signal count : std_logic_vector(31 downto 0) := (others => '0'); 
--------------------------aderivative-----------------
  signal aderivative_DataIn_s2m : axiStream_slv32_s2m := axiStream_slv32_s2m_null;
  signal aderivative_DataIn_m2s : axiStream_slv32_m2s := axiStream_slv32_m2s_null;
  signal aderivative_DataOut_s2m : axiStream_slv32_s2m := axiStream_slv32_s2m_null;
  signal aderivative_DataOut_m2s : axiStream_slv32_m2s := axiStream_slv32_m2s_null;
  signal aderivative_clk : std_logic := '0'; 
-------------------------- end aderivative-----------------
  signal dout : std_logic_vector(31 downto 0) := (others => '0'); 
--------------------------clkgen-----------------
  signal clkgen_clk : std_logic := '0'; 
-------------------------- end clkgen-----------------
-------------------------- end ram_block_tb-----------------

begin
  -- begin architecture
  
-----------------------------------
proc : process(clkgen_clk) is
  variable h_dataout : axiStream_slv32_slave := axiStream_slv32_slave_null;
  variable h_datain : axiStream_slv32_master := axiStream_slv32_master_null;
  begin
    if rising_edge(clkgen_clk) then 
      pull( self  =>  h_dataout, rx => aderivative_DataOut_m2s);
      pull( self  =>  h_datain, tx => aderivative_DataIn_s2m);
  get_value_01_rshift(self => h_dataout, rhs => dout);
    
      if (ready_to_send_0(self => h_datain)) then 
        count <= count + 1;
        
      end if;
        push( self  =>  h_dataout, rx => aderivative_DataOut_s2m);
      push( self  =>  h_datain, tx => aderivative_DataIn_m2s);
  end if;
  
  end process;
  -- end architecture

  aderivative : entity work.ZeroFinder port map (
    DataIn_s2m => aderivative_DataIn_s2m,
    DataIn_m2s => aderivative_DataIn_m2s,
    DataOut_s2m => aderivative_DataOut_s2m,
    DataOut_m2s => aderivative_DataOut_m2s,
    clk => aderivative_clk
  );
  
  clkgen : entity work.clk_generator port map (
    clk => clkgen_clk
  );
  aderivative_clk <= clkgen_clk;
  
end architecture;